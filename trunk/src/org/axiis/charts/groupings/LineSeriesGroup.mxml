<?xml version="1.0" encoding="utf-8"?>
<layouts:RepeaterLayout xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:degrafa="http://www.degrafa.com/2007" name="outerlayout"
	xmlns:core="org.axiis.core.*"
	xmlns:layouts="org.axiis.layouts.*"
	xmlns:scale="org.axiis.layouts.scale.*"
	xmlns:states="org.axiis.states.*"
	xmlns:geom="flash.geom.*" 
	xmlns:utils="org.axiis.utils.*" preRender="onPreRender();">
	
	<!-- public variables -->
	<mx:Script>
		<![CDATA[
			import org.axiis.core.AxiisSprite;
			import flash.utils.getTimer;
			import mx.collections.ArrayCollection;
			import com.degrafa.paint.SolidFill;
			import com.degrafa.decorators.axiis.AreaLineDecorator;
			import com.degrafa.geometry.segment.QuadraticBezierTo;
			import com.degrafa.geometry.segment.ClosePath;
			import com.degrafa.geometry.segment.LineTo;
			import com.degrafa.geometry.segment.MoveTo;
			import com.degrafa.GraphicPoint;
			import com.degrafa.core.IGraphicsStroke;
			import com.degrafa.core.IGraphicsFill;
			import org.axiis.utils.GraphicUtils;
			
			[Inspectable][Bindable]
			public var stroke:IGraphicsStroke;
			
			[Inspectable][Bindable]
			public var fill:IGraphicsFill;
			
			public var plotFilterFunction:Function;
			
			public var _pivotSeries:Boolean=false;
			
			private var _seriesCollection:Object;
			private var _plotCollection:Object;
			
			private var _prevCurvePath:Array;
			
			[Inspectable]
			public function set pivotSeries(value:Boolean):void {
				if (value!=_pivotSeries)
				 {
					_pivotSeries=value;
					if (_dataProvider) dataProvider=_dataProvider; //Need to refresh the way we do this.
				 }
			}
			
			public function get pivotSeries():Boolean {
				return _pivotSeries;
			}
			

			override public function set dataProvider(value:Object):void {
				//Depending on whether "_pivotSeries" is true we will either invert the series collection transpose which collection is the "series" versus the plots.
		
				var oldLength=(_dataItems) ? _dataItems.length:0;
				
				var firstItem:Object=(value is Array) ? value[0]:value.getItemAt(0);
				
				
					var tempItems:Array=new Array();
					
					if (!_pivotSeries) {  //This means our series is (vertically) grouped by each primary OUTER object, and  our plots are (horizontally) grouped by the inner objects
						for (var i:int=0;i<firstItem[plotCollection].length;i++) {
							var obj:Object=(firstItem[plotCollection] is Array) ? firstItem[plotCollection][i]:firstItem[plotCollection].getItemAt(i);
							if (plotFilterFunction) {
								if (plotFilterFunction.call(this,obj)) tempItems.push(obj);
							}
							else {
								tempItems.push(obj);
							}
						}
					}
					else {  //This means our series is (vertically) grouped by each INNER object, and  our plots are (horizontally) grouped by the outer objects
						for (var i:int=0;i<value.length;i++) {
							var obj:Object=(value is Array) ? value[i]:value.getItemAt(i);
							if (dataFilterFunction) {
								if (this.dataFilterFunction.call(this,obj)) tempItems.push(obj);
							}
							else {
								tempItems.push(obj);
							}
						}
					}
				
				_dataItems=tempItems;
				
				_itemCount=_dataItems.length;
				
				_dataProvider=value;
				
				_seriesCollection=_dataProvider;
				
				if (!pivotSeries && dataFilterFunction) {		
					_seriesCollection=new Array();
					for each (var so:Object in _dataProvider) {
						if (dataFilterFunction(so)) _seriesCollection.push(so);
					}
				}
				else if (pivotSeries && plotFilterFunction) {
					tempItems=new Array();
					for (var i:int=0;i<firstItem[plotCollection].length;i++) {
						var obj:Object=(firstItem[plotCollection] is Array) ? firstItem[plotCollection][i]:firstItem[plotCollection].getItemAt(i);
						if (plotFilterFunction.call(this,obj)) tempItems.push(obj);
					}
				}
				
				
				//This will set the repeat cycle for the inner layouts
				plotLayout.dataProvider=(!_pivotSeries) ?  _seriesCollection: tempItems; 
				markerLayout.dataProvider=(!_pivotSeries) ?  _seriesCollection: tempItems;	

				
				_plotCollection=firstItem;	
				
				super.invalidateDataProvider();
				
			
			}
			
			private function onPreRender():void {
				labelField=(!_pivotSeries) ? plotLabelField:seriesLabelField;
			}
			
			private function onPlotPreRender():void {
				if (currentIndex==0) { //We only do this on the first pass
					calculateCurves();
					_decorator.fillBounds=new Rectangle(0,height-_maxHeight,width,_maxHeight);
					if (!showArea) {
						myPath.fill=new SolidFill(0,0);
					}
					else {
						myPath.fill=fill;
					}
				}
			}
			
			
			private function onPlotItemPreDraw():void {

				var seriesIndex:int=(!_pivotSeries || _pivotSeries) ? plotLayout.currentIndex : currentIndex;
				var plotIndex:int=(!_pivotSeries || _pivotSeries) ? currentIndex:plotLayout.currentIndex;
				var plotCount:int=(!_pivotSeries || _pivotSeries) ? itemCount:plotLayout.itemCount;
				_currentSegments=new Array();
							
				//Need to make sure each curve start/stops at same x line (the curves produced are interpolations and have some variance)
				// If we don't do this the fills will overlap
				
				//Always add a "move to for the starting point"
				if (plotIndex==0) {
					_currentSegments=_segmentGroups[seriesIndex].slice(plotIndex,plotIndex+2);
					_currentSegments.splice(0,0,new MoveTo(_currentSegments[0].x,_currentSegments[0].y));
					//Clip end point
					_currentSegments[_currentSegments.length-1].x=Math.round(_repeatWidth/2);  
					
				}
				else if (plotIndex < plotCount-1) {
					_currentSegments=_segmentGroups[seriesIndex].slice(plotIndex*2-1,plotIndex*2+2);
					//Clip Start point
					_currentSegments[0].x=Math.round(_repeatWidth/2)+Math.round(_repeatWidth*(plotIndex-1));
					_currentSegments.splice(0,1,new MoveTo(_currentSegments[0].x,_currentSegments[0].y));
					//Clip End Point
					if (plotIndex < plotCount-2)
						_currentSegments[_currentSegments.length-1].x=Math.round(_repeatWidth/2)+Math.round(_repeatWidth*(currentIndex));
		
				} 
				else if (plotIndex == plotCount-1) {
					_currentSegments=_segmentGroups[seriesIndex].slice(plotIndex*2-1,plotIndex*2);
					_currentSegments.splice(0,1,new MoveTo(_currentSegments[0].x,_currentSegments[0].y));
				} 
				
				//Close our path with sides and bottom lines on first pass or not Stack
				if (seriesIndex==0 ||  this.mode==LineSeriesGroup.MODE_BASELINE || !this.showArea) {
					_prevCurvePath=new Array();
					for (var i:int=0; i < _currentSegments.length; i++) {
						_prevCurvePath.push(_currentSegments[i]);
					}
					_currentSegments.push(new LineTo(_currentSegments[_currentSegments.length-1].x,plotLayout.height))//;
					_currentSegments.push(new LineTo(_currentSegments[0].x,plotLayout.height)); //bottom line;
					_currentSegments.push(new ClosePath());
				}
				else if (this.mode==LineSeriesGroup.MODE_STACK && this.showArea) {
					var tempCurves:Array=new Array();
					
					//Collect our current topmost curves (we will use on next pass as bottom curves if we are stacking areas
					for (var i:int=0; i < _currentSegments.length; i++) { 
						tempCurves.push(_currentSegments[i]);
					}
					
					//Connect to our previous curve
					_currentSegments.push(new LineTo(_prevCurvePath[_prevCurvePath.length-1].x,_prevCurvePath[_prevCurvePath.length-1].y)); 
					
					//Add our previous curve
					for (var i:int=_prevCurvePath.length-1; i >0; i--) {
						//We need to reverse our curve direction use the same control points, but choose the x,y of prior locatioan 
						if (_prevCurvePath[i] is QuadraticBezierTo) {
							var qb:QuadraticBezierTo=_prevCurvePath[i];
							_currentSegments.push(new QuadraticBezierTo(qb.cx,qb.cy,_prevCurvePath[i-1].x,_prevCurvePath[i-1].y));
						}
					}
					_currentSegments.push(new ClosePath());
					_prevCurvePath=tempCurves;

				}
				myPath.segments=_currentSegments;
			}
			
			
			private function onMarkerItemPreDraw():void {
				marker.centerX=_repeatWidth*currentIndex-1;
				yPoint.value=seriesPoints[markerLayout.currentIndex][currentIndex+1].y;
			}
			
			/**
			 * This routine pre-calculates all the curves for a series
			 * While we could calculate on each iteration, it would degrade performance because each curve is depdendent on the previous and next
			 * Thus we cache all the curves up front, and then just takes slices off them to render
			 * Curves are stored in multi-dimensional array
			 * 
			 * segmentGroups[currentIndex][parentLayout.currentIndex]  where currentIndex==the current "series", and parentLayout.currentIndex==the ordinal record position
			 */
			private function calculateCurves():void {
				var t:Number=flash.utils.getTimer();
				if (!plotCollection) return;
				//var segmentWidth:Number=width/itemCount;
				 
				_segmentGroups=new Array();	
				_maxHeight=0;
				//Two dimension array used to store each series fields, one row at a time  Array[hField,vField]
				seriesPoints=new Array();
				_repeatWidth=(width)/(itemCount-1);
				
				var y:int=0;
				var stackedValues:Object=new Object();
				
				//This stores all the plotCollection for one series
				var ta:Array=new Array();
				
				var xo:Number=0; 
				
				for each (var series:Object in _seriesCollection) { //loop through all series to build our plot locations (to be used to generate curves)
					
					//Gather the data values for our plots
					var seriesPlots:Array=new Array();
					for (var n:int=0;n<series[plotCollection].length;n++) {
						var vObj:Object; 
						if (series[plotCollection] is ArrayCollection)  vObj=series[plotCollection].getItemAt(n); else vObj=series[plotCollection][n]; 
						if (plotFilterFunction) {
							if (!plotFilterFunction.call(this,vObj)) continue;
						}
						seriesPlots.push(vObj);
					}
					
					
					
					//Depending on  whether we are pivoting the series we need to always structure the seriesPoints so that each inner array represents all the plot points
					//for inner layout (which repeats horizontally)
					if (!_pivotSeries) {
					 	ta=new Array(); 
					 	seriesPoints.push(ta);
					} 
					
					if(!_pivotSeries) xo=0;
					
					for (var i:int=0;i<seriesPlots.length;i++) { //each series field
					
						//If we are pivoting the series we need to transpose how the points get organized and invert the 2D array;
						if (_pivotSeries) {
							ta=seriesPoints[i];
							if (!ta) {
								ta=new Array();
								seriesPoints.push(ta);
								xo=0;
							}
							
						}
						
						var obj=seriesPlots[i];
						if (ta.length==0) { //adds a new node if it is the first time
							ta.push(new GraphicPoint(-1,verticalScale.valueToLayout(seriesPlots[0][dataField],true))); //The first marker
						}
						
						var gp:GraphicPoint=new GraphicPoint;
						gp.x=xo;
						
						
						if (mode==HLineGroup.MODE_STACK) { //looping through to make stacked values
							var stackedValue:Number=0;
							if (!_pivotSeries) {
								if (!stackedValues[i]) stackedValues[i]=0;
								stackedValues[i]+=obj[dataField];
								stackedValue=stackedValues[i];
							}
							else {
								for (var z:int=0; z <= i ;z++) {
									if (plotFilterFunction) {
										if (!plotFilterFunction.call(this,series[plotCollection][z])) continue;
									}
									stackedValue+=series[plotCollection][z][dataField];
								}
							}
							gp.y=verticalScale.valueToLayout(stackedValue,true);
						}
						else {
							gp.y=verticalScale.valueToLayout(obj[dataField],true);
						}
						
						ta.push(gp);
						_maxHeight=Math.max(_maxHeight,verticalScale.valueToLayout(obj[dataField]),true);
						if (!_pivotSeries) xo+=_repeatWidth;
					} 
					y++;
					if (_pivotSeries) xo+=_repeatWidth;
				}
				
				//Turn the series plotCollection, into curveTo commands
				for each (var ar:Array in seriesPoints) {
					_segmentGroups.push(GraphicUtils.buildSegmentsFromCurvePoints(ar,tension));
				}
				
				trace("computeCurves elapsed time=" + (flash.utils.getTimer()-t) + "ms");
			}
			
			//Stores all the data points (accounts for stacking and alternate layouts
			private var seriesPoints:Array;
			
			//Used to help calculate common fill bounds for myPath
			private var _maxHeight:Number;
			
			//Our repeat width depends on the hPadding 
			[Bindable]
			private var _repeatWidth:Number;
			
			//Stores all the precomputed curve segments
			private var _segmentGroups:Array;
			
			//The segments used to render the series by myPath
			[Bindable]
			private var _currentSegments:Array;
			
			//Used to remove strokes off the sides and bottom of the path
			[Bindable]
			private var _decorator:AreaLineDecorator=new AreaLineDecorator();
			
			//private var _seriesCollection:Object;
			
			public static var MODE_BASELINE:int=0;
			public static var MODE_STACK:int=1;
		]]>
	</mx:Script>
	
	<mx:int id="mode">0</mx:int>
	<mx:Boolean id="showArea">false</mx:Boolean>
	<mx:String id="plotCollection"/>
	<scale:LinearScale id="verticalScale"/>
	<mx:int id="fontSize">12</mx:int>
	<mx:Number id="fontColor">0</mx:Number>
	<mx:String id="fontFamily">Arial</mx:String>
	<mx:String id="fontWeight">normal</mx:String>
	<mx:Boolean id="showLabel">true</mx:Boolean>
	<mx:Number id="tension">.25</mx:Number>
	<mx:int id="markerSize">8</mx:int>
	<mx:Number id="markerColor">0xfa8514</mx:Number>
	<mx:Boolean id="showMarker">true</mx:Boolean>
	<mx:String id="seriesLabelField"></mx:String>
	<mx:String id="plotLabelField"></mx:String>
	
	<utils:NumericExpression id="yPoint"/>
	
	<layouts:layouts>
		<layouts:RepeaterLayout id="plotLayout" width="{currentReference.width}" height="{currentReference.height}" name="plotLayout"
			preRender="onPlotPreRender();" scaleFill="true" x="0" y="0" inheritParentBounds="false"
			itemPreDraw="onPlotItemPreDraw();">
			<layouts:drawingGeometries>
				<degrafa:RegularRectangle width="{width}" height="{height}" x="0" y="0">
					<degrafa:Path id="myPath"  scaleOnLayout="false"  decorators="{[_decorator]}" 
							visible="{(_currentSegments.length>1)}"
							stroke="{stroke}"
							fill="{fill}"
							segments="{_currentSegments}"
							>
					</degrafa:Path>
				</degrafa:RegularRectangle>	
		</layouts:drawingGeometries>
		
		</layouts:RepeaterLayout>
		<layouts:RepeaterLayout id="markerLayout" width="{currentReference.width}" height="{currentReference.height}" name="markerLayout"
			scaleFill="true" x="0" y="0" inheritParentBounds="false" itemPreDraw="onMarkerItemPreDraw();">
			<layouts:drawingGeometries>
			
			<degrafa:Circle id="marker"  radius="{markerSize/2}" centerY="{yPoint.value}" visible="{showMarker}">
				<degrafa:fill><degrafa:SolidFill color="0xFFFFFF" alpha=".8"/></degrafa:fill>
				<degrafa:stroke><degrafa:SolidStroke color="0" pixelHinting="false" alpha=".6"/></degrafa:stroke>
			</degrafa:Circle>
			<degrafa:Circle id="innerMarker" radius="{markerSize/2*.6}" centerX="{marker.centerX}" centerY="{marker.centerY}" visible="{showMarker}">
				<degrafa:fill><degrafa:SolidFill color="{markerColor}" alpha="1"/></degrafa:fill>
			</degrafa:Circle>
			
		</layouts:drawingGeometries>
		
		</layouts:RepeaterLayout>
	</layouts:layouts>
	
</layouts:RepeaterLayout>