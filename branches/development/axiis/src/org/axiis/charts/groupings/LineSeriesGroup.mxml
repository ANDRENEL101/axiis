<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright (c) 2009 Team Axiis

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
-->
<layouts:RepeaterLayout xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:degrafa="http://www.degrafa.com/2007" name="outerlayout"
	xmlns:core="org.axiis.core.*"
	xmlns:layouts="org.axiis.layouts.*"
	xmlns:scale="org.axiis.layouts.scale.*"
	xmlns:states="org.axiis.states.*"
	xmlns:geom="flash.geom.*" 
	xmlns:utils="org.axiis.utils.*" preRender="onPreRender();">
	
	<!-- public variables -->
	<mx:Script>
		<![CDATA[
			import com.degrafa.paint.LinearGradientFill; 
			import org.axiis.core.AxiisSprite;
			import flash.utils.getTimer;
			import mx.collections.ArrayCollection;
			import com.degrafa.paint.SolidFill;
			import com.degrafa.decorators.axiis.AreaLineDecorator;
			import com.degrafa.geometry.segment.QuadraticBezierTo;
			import com.degrafa.geometry.segment.ClosePath;
			import com.degrafa.geometry.segment.LineTo;
			import com.degrafa.geometry.segment.MoveTo;
			import com.degrafa.GraphicPoint;
			import com.degrafa.core.IGraphicsStroke;
			import com.degrafa.core.IGraphicsFill;
			import org.axiis.utils.GraphicUtils;
			
			[Inspectable][Bindable]
			public var stroke:com.degrafa.core.IGraphicsStroke;
			
			[Inspectable][Bindable]
			public var fill:com.degrafa.core.IGraphicsFill;
			
			public var plotFilterFunction:Function;
			
			public var _pivotSeries:Boolean=false;
			
			private var _seriesCollection:Object;
			private var _plotCollection:Object;
			
			private var _prevCurvePath:Array;
			private var _maxY:Array;
			private var _minY:Array;
			
			private var t:Number;
			override public function render(newSprite:AxiisSprite=null):void {
				t=flash.utils.getTimer();
				super.render(newSprite);
				
				
			}
			
			override protected function repeatComplete():void {
				trace("LineSeriesGroup.render elapsed=" + (flash.utils.getTimer()-t) + "ms");
			}
			override public function invalidateDataProvider():void {
					super.invalidateDataProvider();
					
					var firstItem:Object=(_dataProvider is Array) ? _dataProvider[0]:_dataProvider.getItemAt(0);
			
					var tempItems:Array=new Array();
					
						for (var i:int=0;i<firstItem[plotCollection].length;i++) {
							var obj:Object=(firstItem[plotCollection] is Array) ? firstItem[plotCollection][i]:firstItem[plotCollection].getItemAt(i);
							if (plotFilterFunction != null) {
								if (plotFilterFunction.call(this,obj)) tempItems.push(obj);
							}
							else {
								tempItems.push(obj);
							}
						}
					
				_seriesCollection=_dataItems;
				
				_dataItems=tempItems;
				
				_itemCount=_dataItems.length;
			
				//This will set the repeat cycle for the inner layouts
				plotLayout.dataProvider=  _seriesCollection; 
				markerLayout.dataProvider= _seriesCollection;		

				
				_plotCollection=firstItem;	
			}
			private function onPreRender():void {
				labelField=(!_pivotSeries) ? plotLabelField:seriesLabelField;
			}
			
			private function onPlotPreRender():void {
				if (currentIndex==0) { //We only do this on the first pass
					calculateCurves();
			
					if (!showArea) {
						myPath.fill=new SolidFill(0,0);
					}
					else {
						myPath.fill=fill;
					}
				}
				
				
			}
			
			//Gets our current curves and rounds at borders between repeater sprites
			private function getSegments(seriesIndex:int, paths:Array):Array {
				
				var segments:Array=new Array();
				if (currentIndex==0) {
					segments=paths[seriesIndex].slice(currentIndex,currentIndex+2);
					segments.splice(0,0,new MoveTo(segments[0].x,segments[0].y));
					//Clip end point
					segments[segments.length-1].x=Math.round(_repeatWidth/2);  
					
				}
				else if (currentIndex < itemCount-1) {
					segments=paths[seriesIndex].slice(currentIndex*2-1,currentIndex*2+2);
					//Clip Start point
					segments[0].x=Math.round(_repeatWidth/2)+Math.round(_repeatWidth*(currentIndex-1));
					segments.splice(0,1,new MoveTo(segments[0].x,segments[0].y));
					//Clip End Point
					if (currentIndex < itemCount-2)
						segments[segments.length-1].x=Math.round(_repeatWidth/2)+Math.round(_repeatWidth*(currentIndex));
		
				} 
				else if (currentIndex == itemCount-1) {
					segments=paths[seriesIndex].slice(currentIndex*2-1,currentIndex*2);
					segments.splice(0,1,new MoveTo(segments[0].x,segments[0].y));
				} 
				
				return segments;
			}
			
			/**
			 * We are going to take slices out of our _curvePathsTop, one slice (2 curves) for each horizontal repeater item
			 * If we have an area we then close the path with another slice out of the _curvePathsBottom
			 */
			private function onPlotItemPreDraw():void {
				
				var h:Number;
				var y:Number;
				var seriesIndex:int=plotLayout.currentIndex;
				
				/**
				 * Need to set our fill bounds for each series
				 */
				if (mode==LineSeriesGroup.MODE_BASELINE) {
					_decorator.fillBounds=new Rectangle(0,int(_minY[seriesIndex]),width,height-int(_minY[seriesIndex]));
				}
				else if (mode==LineSeriesGroup.MODE_STACK_ZERO) {
					if (seriesIndex==0) {
						h=height-_minY[seriesIndex];
						y=_minY[seriesIndex];
					}
					else {
						h=_maxY[seriesIndex-1]-_minY[seriesIndex];
						y=_minY[seriesIndex];
					}
					_decorator.fillBounds=new Rectangle(0,y,width,h);
				}
				
				else if (mode==LineSeriesGroup.MODE_STACK_FLOW) {
					if (seriesIndex==0) {
						h=(_maxY[seriesIndex]-_minY[seriesIndex])*2;
						y=_minY[seriesIndex];
					}
					else if (seriesIndex % 2 == 1) {
						h=_maxY[seriesIndex-1]-_minY[seriesIndex];
						y=_minY[seriesIndex];
					}
					else {
						h=(_maxY[seriesIndex]-_minY[seriesIndex])*-1;
						y=_maxY[seriesIndex];
					}
					
					_decorator.fillBounds=new Rectangle(0,y,width,h);
				}
				trace ("decorator y=" + _decorator.fillBounds.y + " height=" + _decorator.fillBounds.height);
				
				myPath.stroke=stroke;
				
				var t:Number=flash.utils.getTimer();
			

				_currentSegments=getSegments(seriesIndex,_curvePathsTop);
							
				if (this.showArea) {
					
					_prevCurvePath=getSegments(seriesIndex,_curvePathsBottom);
					
					//Connect to our previous curves	
					_currentSegments.push(new LineTo(_prevCurvePath[_prevCurvePath.length-1].x,_prevCurvePath[_prevCurvePath.length-1].y)); 
				
					//Add our previous curve
					for (var i:int=_prevCurvePath.length-1; i >0; i--) {
						//We need to reverse our curve direction use the same control points, but choose the x,y of prior locatioan 
						if (_prevCurvePath[i] is QuadraticBezierTo) {
							var qb:QuadraticBezierTo=_prevCurvePath[i];
							_currentSegments.push(new QuadraticBezierTo(qb.cx,qb.cy,_prevCurvePath[i-1].x,_prevCurvePath[i-1].y));
						}
					}
					_currentSegments.push(new ClosePath());

				}
				myPath.segments=_currentSegments;
				
			
				//trace("onPlotItemPreDraw elapsed time=" + (flash.utils.getTimer()-t) + "ms");
			}
			
			
			private function onMarkerItemPreDraw():void {
				marker.centerX=_repeatWidth*currentIndex-1;
				marker.visible=this.showMarker;
				innerMarker.visible=this.showMarker;
				
				if (!this.showMarker) return;
				
				if (mode==LineSeriesGroup.MODE_STACK_FLOW && markerLayout.currentIndex==0) {
					yPoint.value=verticalScale.valueToLayout(0,true);
					trace("yPoint Value=" + yPoint.value);
				}
				else if (mode==LineSeriesGroup.MODE_STACK_FLOW && (markerLayout.currentIndex==1 || markerLayout.currentIndex==3)) {  //Resolves the fact that the first series is bisected
					marker.visible=false;
					innerMarker.visible=false;
				}
				else if (mode==LineSeriesGroup.MODE_STACK_FLOW && markerLayout.currentIndex==2) {
					yPoint.value=seriesPoints[markerLayout.itemCount][currentIndex+1].y;
					//marker.centerX+=10;
				}
				else {
					
					yPoint.value=seriesPoints[markerLayout.currentIndex][currentIndex+1].y;
				}
				
				
			}
			
			/**
			 * This routine pre-calculates all the curves for a series
			 * While we could calculate on each iteration, it would degrade performance because each curve is depdendent on the previous and next point along its path
			 * Thus we cache all the curve segments up front, and then just takes slices off them to render
			 * Curves are stored in multi-dimensional array
			 * 
			 * segmentGroups[currentIndex][parentLayout.currentIndex]  where currentIndex==the current "series", and parentLayout.currentIndex==the plot point along the curve
			 */
			private function calculateCurves():void {
				_minY=new Array();
				_maxY=new Array();
				var t:Number=flash.utils.getTimer();
				if (!plotCollection) return;
				//var segmentWidth:Number=width/itemCount;
				 
				_curvePathsTop=new Array();	
			
				//Two dimension array used to store each series fields, one row at a time  Array[hField,vField]
				seriesPoints=new Array();
				_repeatWidth=(width)/(itemCount-1);
				
				var y:int=0;
				var stackedValues:Object=new Object();  //Represents positive values for STACK layouts
				var stackedValues2:Object=new Object();
				
				//This stores all the plotCollection for one series
				var ta:Array=new Array();
				var flowTa:Array;
				
				var xo:Number=0; 
		
				
				for each (var series:Object in _seriesCollection) { //loop through all series to build our plot locations (to be used to generate curves)
					
					//Gather the data values for our plots
					var seriesPlots:Array=new Array();
					for (var n:int=0;n<series[plotCollection].length;n++) {
						var vObj:Object; 
						if (series[plotCollection] is ArrayCollection)  vObj=series[plotCollection].getItemAt(n); else vObj=series[plotCollection][n]; 
						if (plotFilterFunction != null) {
							if (!plotFilterFunction.call(this,vObj)) continue;
						}
						
						seriesPlots.push(vObj);
					}
					
					//Create temp array to store points
					ta=new Array(); 					
					xo=0;
				
					
					
					for (var i:int=0;i<seriesPlots.length;i++) { //each series field
						var stackedValue:Number=0;
						var obj:Object=seriesPlots[i];
						if (ta.length==0) { //adds a new node if it is the first time
							ta.push(new GraphicPoint(-1,verticalScale.valueToLayout(seriesPlots[0][dataField],true))); //The first marker
						}
						
						var gp:GraphicPoint=new GraphicPoint;
						gp.x=xo;
						
						
						if (mode==LineSeriesGroup.MODE_STACK_ZERO) { //looping through to make stacked values

							if (!stackedValues[i]) stackedValues[i]=0;
							stackedValues[i]+=obj[dataField];
							stackedValue=stackedValues[i];
							
							gp.y=verticalScale.valueToLayout(stackedValue,true);
						}
						else if (mode==LineSeriesGroup.MODE_STACK_FLOW) {
							//First item gets split across the zero line
							//Then we alternate positions
							if (y==0) {
								if (!flowTa) flowTa=new Array();
								//For now make two gp's that are bisected at zero
								var gp2:GraphicPoint = new GraphicPoint;
								gp2.x=gp.x;								
								if (!stackedValues2[i]) stackedValues2[i]=0;
								stackedValues2[i]-=obj[dataField]/2;
								gp2.y=verticalScale.valueToLayout(stackedValues2[i],true);
								if (flowTa.length==0) flowTa.push(new GraphicPoint(-1,gp2.y));  //First point in series
								flowTa.push(gp2);
								if (!stackedValues[i]) stackedValues[i]=0;
								stackedValues[i]+=obj[dataField]/2;
								gp.y=verticalScale.valueToLayout(stackedValues[i],true);
								
							}
							else if (y % 2 == 1) {
								if (!stackedValues[i]) stackedValues[i]=0;
								stackedValues[i]+=obj[dataField];
								stackedValue=stackedValues[i];
								gp.y=verticalScale.valueToLayout(stackedValue,true);
							}
							else {
								if (!stackedValues2[i]) stackedValues2[i]=0;
								stackedValues2[i]-=obj[dataField];
								stackedValue=stackedValues2[i];
								gp.y=verticalScale.valueToLayout(stackedValue,true);
							}
						}
						else {
							gp.y=verticalScale.valueToLayout(obj[dataField],true);
						}
						
						ta.push(gp);
						if (y > _minY.length-1) _minY.push(height);
						if (y > _maxY.length-1) _maxY.push(0);
						_minY[y]=Math.min(_minY[y],gp.y);
						_maxY[y]=Math.max(_maxY[y],gp.y);
						 xo+=_repeatWidth;
					} 
					//We have a STACK_FLOW and are at first series we add a series for the bisection
					if (mode==LineSeriesGroup.MODE_STACK_FLOW && y==0) {
						seriesPoints.push(flowTa);
					}
					seriesPoints.push(ta);
					
					y++;
				}
		
				//Turn the series plotCollection, into curveTo commands
				
				for each (var ar:Array in seriesPoints) {
					_curvePathsTop.push(GraphicUtils.buildSegmentsFromCurvePoints(ar,tension));
				}
				
				//Create a set of paths we can connect as bottom curves
				if (this.showArea) {
					_curvePathsBottom=new Array();
					
					i=0;
					for (obj in _curvePathsTop) {
						if (mode==LineSeriesGroup.MODE_STACK_FLOW) {  //Our series alternate with the first one being split into two, then going positive/negative
							if (i==1) {
								_curvePathsBottom.push(_curvePathsTop[0]);
							}
							else if (i == 3) {
								_curvePathsBottom.push(_curvePathsTop[0]);
							}
							else if (i > 0) { //We should be a positive value here, so our "bottom" was the last positive value
								_curvePathsBottom.push(_curvePathsTop[i-2]);
							}
							
							
						}
						else { //When we have a baseline axis we will create a straight line for the bottom by adding a new path and ignoring the last one
							if (i==0 || mode==LineSeriesGroup.MODE_BASELINE) {
								//First bottom curve is a straigh line;
								var path:Array=new Array();
								for (n=0;n<_curvePathsTop[0].length;n++) {
									var q:QuadraticBezierTo=new QuadraticBezierTo(_curvePathsTop[0][n].cx,verticalScale.valueToLayout(0,true),_curvePathsTop[0][n].x,verticalScale.valueToLayout(0,true));
									path.push(q);
								}
							 _curvePathsBottom.push(path);
							}
							else {
								_curvePathsBottom.push(_curvePathsTop[i-1]);
							}
							
						}
						
						i++;
					}
					
					if (mode==LineSeriesGroup.MODE_STACK_FLOW) { //Remove the first one as it was the result of splitting the first series by bisecting the zero line
						_curvePathsTop.splice(0,1);
					}
					
					
				}
				//Now we have our continuous path we need to break them up into segments
				
				
				trace("computeCurves elapsed time=" + (flash.utils.getTimer()-t) + "ms");
			}
			
			//Stores all the data points (accounts for stacking and alternate layouts
			private var seriesPoints:Array;
			
			//Used to help calculate common fill bounds for myPath
			private var _maxHeight:Number;
			
			//Our repeat width depends on the hPadding 
			[Bindable]
			private var _repeatWidth:Number;
			
			//Stores all the precomputed curve segments
			private var _curvePathsTop:Array;
			
			//Stores all the precomputed curve segments
			private var _curvePathsBottom:Array;
			
			//The segments used to render the series by myPath
			[Bindable]
			private var _currentSegments:Array;
			
			//Used to remove strokes off the sides and bottom of the path
			[Bindable]
			private var _decorator:AreaLineDecorator=new AreaLineDecorator();
			
			//private var _seriesCollection:Object;
			public static const MODE_BASELINE:int=0;			
			public static const MODE_STACK_ZERO:int=1;
			public static const MODE_STACK_FLOW:int=2;
		]]>
	</mx:Script>
	
	<mx:int id="mode">0</mx:int>
	<mx:Boolean id="showArea">false</mx:Boolean>
	<mx:String id="plotCollection"/>
	<scale:LinearScale id="verticalScale"/>
	<mx:int id="fontSize">12</mx:int>
	<mx:Number id="fontColor">0</mx:Number>
	<mx:String id="fontFamily">Arial</mx:String>
	<mx:String id="fontWeight">normal</mx:String>
	<mx:Boolean id="showLabel">true</mx:Boolean>
	<mx:Number id="tension">.25</mx:Number>
	<mx:int id="markerSize">8</mx:int>
	<mx:Number id="markerColor">0xfa8514</mx:Number>
	<mx:Boolean id="showMarker">true</mx:Boolean>
	<mx:String id="seriesLabelField"></mx:String>
	<mx:String id="plotLabelField"></mx:String>
	
	<utils:NumericExpression id="yPoint"/>
	<degrafa:SolidFill color="0xFFFF00" alpha=".7" id="rollOverFill"/>
	<layouts:layouts>
		<layouts:RepeaterLayout id="plotLayout" width="{currentReference.width}" height="{currentReference.height}" name="plotLayout"
			preRender="onPlotPreRender();" scaleFill="true" x="0" y="0" inheritParentBounds="false"
			itemPreDraw="onPlotItemPreDraw();">
			<layouts:drawingGeometries>
				<degrafa:RegularRectangle width="{width}" height="{height}" x="0" y="0">
					<degrafa:Path id="myPath"  scaleOnLayout="false"  decorators="{[_decorator]}"  enableEvents="false"
							visible="{(_currentSegments.length>1)}"
							stroke="{stroke}"
							fill="{fill}"
							segments="{_currentSegments}"
							>
					</degrafa:Path>
				</degrafa:RegularRectangle>	
			</layouts:drawingGeometries>
		</layouts:RepeaterLayout>
			<layouts:RepeaterLayout id="markerLayout" width="{currentReference.width}" height="{currentReference.height}" name="markerLayout"
				scaleFill="true" x="0" y="0" inheritParentBounds="false" itemPreDraw="onMarkerItemPreDraw();">
				<layouts:drawingGeometries>
				
				<degrafa:Circle id="marker"  radius="{markerSize/2}" centerY="{yPoint.value}" visible="{showMarker}" enableEvents="false">
					<degrafa:fill><degrafa:SolidFill color="0xFFFFFF" alpha=".8"/></degrafa:fill>
					<degrafa:stroke><degrafa:SolidStroke color="0" pixelHinting="false" alpha=".6"/></degrafa:stroke>
				</degrafa:Circle>
				<degrafa:Circle id="innerMarker" radius="{markerSize/2*.6}" centerX="{marker.centerX}" centerY="{marker.centerY}" visible="{showMarker}" enableEvents="false">
					<degrafa:fill><degrafa:SolidFill color="{markerColor}" alpha="1"/></degrafa:fill>
				</degrafa:Circle>
				
			</layouts:drawingGeometries>
		
		</layouts:RepeaterLayout>
	</layouts:layouts>
	
</layouts:RepeaterLayout>