<?xml version="1.0" encoding="utf-8"?>
<layouts:RepeaterLayout xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:degrafa="http://www.degrafa.com/2007" name="outerlayout"
	xmlns:core="org.axiis.core.*"
	xmlns:layouts="org.axiis.layouts.*"
	xmlns:scale="org.axiis.layouts.scale.*"
	xmlns:states="org.axiis.states.*"
	xmlns:geom="flash.geom.*"
	xmlns:utils="org.axiis.utils.*">
	
	<!-- public variables -->
	<mx:Script>
		<![CDATA[
			import org.axiis.core.AxiisSprite;
			import flash.utils.getTimer;
			import mx.collections.ArrayCollection;
			import com.degrafa.paint.SolidFill;
			import com.degrafa.decorators.axiis.AreaLineDecorator;
			import com.degrafa.geometry.segment.QuadraticBezierTo;
			import com.degrafa.geometry.segment.ClosePath;
			import com.degrafa.geometry.segment.LineTo;
			import com.degrafa.geometry.segment.MoveTo;
			import com.degrafa.GraphicPoint;
			import com.degrafa.core.IGraphicsStroke;
			import com.degrafa.core.IGraphicsFill;
			import org.axiis.utils.GraphicUtils;
			
			[Inspectable][Bindable]
			public var stroke:IGraphicsStroke;
			
			[Inspectable][Bindable]
			public var fill:IGraphicsFill;
			
			public var seriesFilterFunction:Function;
			
			private var _prevCurvePath:Array;
			
			override public function set dataProvider(value:Object):void {
				//We need to invert the data provider and set the dataItems as the first element of our plotCollection to repeat against
				
	
				var firstItem:Object=(value is Array) ? value[0]:value.getItemAt(0);
				
				
				if (this.dataFilterFunction) {
					var tempItems:Array=new Array();
					for (var i:int=0;i<firstItem[plotCollection].length;i++) {
						var obj:Object=(firstItem[plotCollection] is Array) ? firstItem[plotCollection][i]:firstItem[plotCollection].getItemAt(i);
						if (this.dataFilterFunction.call(this,obj)) tempItems.push(obj);
					}
					_dataItems=tempItems;
				}	
				else {
					_dataItems=firstItem[plotCollection];
				}			
				_dataProvider=value;
				
				plotLayout.dataProvider=value;
				markerLayout.dataProvider=value;				
			}
			/**
			 * Stores the pre-computed curve segments
			 */
			private function onPlotPreRender():void {
				if (currentIndex==0) { //We only do this on the first pass
					calculateCurves();
					_decorator.fillBounds=new Rectangle(0,height-_maxHeight,width,_maxHeight);
					if (!showArea) {
						myPath.fill=new SolidFill(0,0);					}
					else {
						myPath.fill=fill;
					}
				}
			}
			
			
			private function onPlotItemPreDraw():void {
				
				//Render in reverse order (accomodates stack and fills overlaying markers)
				var currIndex:int=plotLayout.currentIndex;
				_currentSegments=new Array();
							
				//Need to make sure each curve start/stops at same x line (the curves produced are interpolations and have some variance)
				// If we don't do this the fills will overlap
				
				//Always add a "move to for the starting point"
				if (currentIndex==0) {
					_currentSegments=_segmentGroups[currIndex].slice(currentIndex,currentIndex+2);
					_currentSegments.splice(0,0,new MoveTo(_currentSegments[0].x,_currentSegments[0].y));
					//Clip end point
					_currentSegments[_currentSegments.length-1].x=Math.round(_repeatWidth/2);  
					
				}
				else if (currentIndex < itemCount-1) {
					_currentSegments=_segmentGroups[currIndex].slice(currentIndex*2-1,currentIndex*2+2);
					//Clip Start point
					_currentSegments[0].x=Math.round(_repeatWidth/2)+Math.round(_repeatWidth*(currentIndex-1));
					_currentSegments.splice(0,1,new MoveTo(_currentSegments[0].x,_currentSegments[0].y));
					//Clip End Point
					if (currentIndex < itemCount-2)
						_currentSegments[_currentSegments.length-1].x=Math.round(_repeatWidth/2)+Math.round(_repeatWidth*(currentIndex));
		
				} 
				else if (currentIndex == itemCount-1) {
					_currentSegments=_segmentGroups[currIndex].slice(currentIndex*2-1,currentIndex*2);
					_currentSegments.splice(0,1,new MoveTo(_currentSegments[0].x,_currentSegments[0].y));
				} 
				
				//Close our path with sides and bottom lines on first pass or not Stack
				if (currIndex==0 ||  this.mode==LineSeriesGroup.MODE_BASELINE || !this.showArea) {
					_prevCurvePath=new Array();
					for (var i:int=0; i < _currentSegments.length; i++) {
						_prevCurvePath.push(_currentSegments[i]);
					}
					_currentSegments.push(new LineTo(_currentSegments[_currentSegments.length-1].x,plotLayout.height))//;
					_currentSegments.push(new LineTo(_currentSegments[0].x,plotLayout.height)); //bottom line;
					_currentSegments.push(new ClosePath());
				}
				else if (this.mode==LineSeriesGroup.MODE_STACK && this.showArea) {
					var tempCurves:Array=new Array();
					for (var i:int=0; i < _currentSegments.length; i++) { //Collect our current topmost curves (we will use on next pass as bottom curves)
						tempCurves.push(_currentSegments[i]);
					}
					
					_currentSegments.push(new LineTo(_prevCurvePath[_prevCurvePath.length-1].x,_prevCurvePath[_prevCurvePath.length-1].y));//connect to previous curve
					
					for (var i:int=_prevCurvePath.length-1; i >0; i--) { //Add the top most curves s
						//We need to reverse our curve direction use the same control points, but choose the x,y of prior locatioan 
						if (_prevCurvePath[i] is QuadraticBezierTo) {
							var qb:QuadraticBezierTo=_prevCurvePath[i];
							_currentSegments.push(new QuadraticBezierTo(qb.cx,qb.cy,_prevCurvePath[i-1].x,_prevCurvePath[i-1].y));
						}
					}
					_currentSegments.push(new ClosePath());
					_prevCurvePath=tempCurves;

				}
				//If we are a stack our bottom line is the top line of the previous item
				
				

				
				myPath.segments=_currentSegments;
				

			}
			
			
			private function onMarkerItemPreDraw():void {
				marker.centerX=_repeatWidth*currentIndex-1;
				yPoint.value=tempPoints[markerLayout.currentIndex][currentIndex+1].y;
			}
			
			/**
			 * This routine pre-calculates all the curves for a series
			 * While we could calculate on each iteration, it would degrade performance because each curve is depdendent on the previous and next
			 * Thus we cache all the curves up front, and then just takes slices off them to render
			 * Curves are stored in multi-dimensional array
			 * 
			 * segmentGroups[currentIndex][parentLayout.currentIndex]  where currentIndex==the current "series", and parentLayout.currentIndex==the ordinal record position
			 */
			private function calculateCurves():void {
				var t:Number=flash.utils.getTimer();
				if (!plotCollection) return;
				//var segmentWidth:Number=width/itemCount;
				
				_segmentGroups=new Array();	
				_maxHeight=0;
				//Two dimension array used to store each series fields, one row at a time  Array[hField,vField]
				tempPoints=new Array();
				_repeatWidth=(width)/(itemCount-1);
				
				//Go through each of the parent collections and serially build a list of points, then turn into bezier curves 
				var y:int=0;
				var stackedValues:Object=new Object();
				for each (var series:Object in _dataProvider) { //spans series fields
					var seriesPlots:Array=new Array();
					for (var n:int=0;n<series[plotCollection].length;n++) {
						var vObj:Object; 
						if (series[plotCollection] is ArrayCollection)  vObj=series[plotCollection].getItemAt(n); else vObj=series[plotCollection][n]; 
						if (dataFilterFunction) {
							if (!dataFilterFunction.call(this,vObj)) continue;
						}
						seriesPlots.push(vObj);
					}
					var ta:Array=new Array(); //This stores all the plotCollection for one series
					tempPoints.push(ta); //This stores all the series plotCollection together
					var xo:Number=0; 
					
					for (var i:int=0;i<seriesPlots.length;i++) { //each series field
						var obj=seriesPlots[i];
						
						if (i==0) { //adds a new node if it is the first time
							ta.push(new GraphicPoint(-1,verticalScale.valueToLayout(seriesPlots[0][dataField],true))); //The first marker
						}
						var gp:GraphicPoint=new GraphicPoint;
						gp.x=xo;
						
						
						if (mode==HLineGroup.MODE_STACK) { //looping through to make stacked values
							if (!stackedValues[i]) stackedValues[i]=0;
							stackedValues[i]+=obj[dataField];
							gp.y=verticalScale.valueToLayout(stackedValues[i],true);
						}
						else {
							gp.y=verticalScale.valueToLayout(obj[dataField],true);
						}
						
						ta.push(gp);
						_maxHeight=Math.max(_maxHeight,verticalScale.valueToLayout(obj[dataField]),true);
						xo+=_repeatWidth;
					} 
					y++;
					trace("stack end");
				}
				
				//Turn the series plotCollection, into curveTo commands
				for each (var ar:Array in tempPoints) {
					_segmentGroups.push(GraphicUtils.buildSegmentsFromCurvePoints(ar,tension));
				}
				
				trace("computeCurves elapsed time=" + (flash.utils.getTimer()-t) + "ms");
			}
			
			//Stores all the data points (accounts for stacking and alternate layouts
			private var tempPoints:Array;
			
			//Used to help calculate common fill bounds for myPath
			private var _maxHeight:Number;
			
			//Our repeat width depends on the hPadding 
			[Bindable]
			private var _repeatWidth:Number;
			
			//Stores all the precomputed curve segments
			private var _segmentGroups:Array;
			
			//The segments used to render the series.
			[Bindable]
			private var _currentSegments:Array;
			
			//Used to remove strokes off the sides and bottom of the path
			[Bindable]
			private var _decorator:AreaLineDecorator=new AreaLineDecorator();
			
			public static var MODE_BASELINE:int=0;
			public static var MODE_STACK:int=1;
		]]>
	</mx:Script>
	
	<mx:int id="mode">0</mx:int>
	<mx:Boolean id="showArea">false</mx:Boolean>
	<mx:String id="plotCollection"/>
	<scale:LinearScale id="verticalScale"/>
	<mx:int id="fontSize">12</mx:int>
	<mx:Number id="fontColor">0</mx:Number>
	<mx:String id="fontFamily">Arial</mx:String>
	<mx:String id="fontWeight">normal</mx:String>
	<mx:Boolean id="showLabel">true</mx:Boolean>
	<mx:Number id="tension">.25</mx:Number>
	<mx:int id="markerRadius">5</mx:int>
	<mx:Number id="markerColor">0xfa8514</mx:Number>
	
	
	<utils:NumericExpression id="yPoint"/>
	
	<layouts:layouts>
		<layouts:HorizontalBoxLayout id="plotLayout" width="{currentReference.width}" height="{currentReference.height}"
			preRender="onPlotPreRender();" scaleFill="true" x="0" y="0" inheritParentBounds="false"
			itemPreDraw="onPlotItemPreDraw();">
			<layouts:drawingGeometries>
				<degrafa:RegularRectangle width="{width}" height="{height}" x="0" y="0">
					<degrafa:Path id="myPath"  scaleOnLayout="false"  decorators="{[_decorator]}" 
							visible="{(_currentSegments.length>1)}"
							stroke="{stroke}"
							fill="{fill}"
							segments="{_currentSegments}"
							>
					</degrafa:Path>
				</degrafa:RegularRectangle>
			
	
			<!--degrafa:Circle id="marker"  radius="{markerRadius}" centerY="{yPoint.value}">
				<degrafa:fill><degrafa:SolidFill color="0xFFFFFF" alpha=".8"/></degrafa:fill>
				<degrafa:stroke><degrafa:SolidStroke color="0" pixelHinting="false" alpha=".6"/></degrafa:stroke>
			</degrafa:Circle>
			<degrafa:Circle id="innerMarker" radius="{markerRadius*.6}" centerX="{marker.centerX}" centerY="{marker.centerY}">
				<degrafa:fill><degrafa:SolidFill color="{markerColor}" alpha="1"/></degrafa:fill>
			</degrafa:Circle-->
			
		</layouts:drawingGeometries>
		
		</layouts:HorizontalBoxLayout>
		<layouts:HorizontalBoxLayout id="markerLayout" width="{currentReference.width}" height="{currentReference.height}"
			scaleFill="true" x="0" y="0" inheritParentBounds="false" itemPreDraw="onMarkerItemPreDraw();">
			<layouts:drawingGeometries>
			
			<degrafa:Circle id="marker"  radius="{markerRadius}" centerY="{yPoint.value}">
				<degrafa:fill><degrafa:SolidFill color="0xFFFFFF" alpha=".8"/></degrafa:fill>
				<degrafa:stroke><degrafa:SolidStroke color="0" pixelHinting="false" alpha=".6"/></degrafa:stroke>
			</degrafa:Circle>
			<degrafa:Circle id="innerMarker" radius="{markerRadius*.6}" centerX="{marker.centerX}" centerY="{marker.centerY}">
				<degrafa:fill><degrafa:SolidFill color="{markerColor}" alpha="1"/></degrafa:fill>
			</degrafa:Circle>
			
		</layouts:drawingGeometries>
		
		</layouts:HorizontalBoxLayout>
	</layouts:layouts>
	
</layouts:RepeaterLayout>